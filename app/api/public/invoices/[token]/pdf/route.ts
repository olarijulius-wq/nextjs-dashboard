export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextResponse } from 'next/server';
import type PDFDocumentType from 'pdfkit';
import postgres from 'postgres';
import { verifyPayToken } from '@/app/lib/pay-link';
import { formatDateToLocal } from '@/app/lib/utils';

const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });
const PDFDocument = require('pdfkit/js/pdfkit.standalone') as typeof PDFDocumentType;

function formatAmountForPdf(amountCents: number) {
  const value = amountCents / 100;
  return `${value.toFixed(2)} EUR`;
}

async function buildInvoicePdf(input: {
  invoice: {
    id: string;
    customer_name: string;
    customer_email: string;
    status: string;
    date: string;
    due_date: string | null;
    amount: number;
    invoice_number: string | null;
    description: string | null;
  };
  company: {
    companyName: string;
    address: string;
    companyEmail: string;
  };
}) {
  return new Promise<Buffer>((resolve, reject) => {
    const doc = new PDFDocument({ margin: 50 });
    const chunks: Buffer[] = [];

    doc.on('data', (chunk: Buffer) => chunks.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);

    const invoiceLabel = input.invoice.invoice_number ?? input.invoice.id.slice(0, 8);
    doc.fontSize(22).text(input.company.companyName || 'Lateless', 50, 60);
    doc.fontSize(14).text(`Invoice ${invoiceLabel}`, 50, 92);

    doc.moveDown(2);
    doc.fontSize(12).text('From');
    if (input.company.address) doc.text(input.company.address);
    if (input.company.companyEmail) doc.text(`Email: ${input.company.companyEmail}`);

    doc.moveDown();
    doc.fontSize(12).text('To');
    doc.text(input.invoice.customer_name);
    doc.text(input.invoice.customer_email);

    doc.moveDown();
    doc.fontSize(12).text(`Date: ${formatDateToLocal(input.invoice.date)}`);
    doc.text(`Due date: ${input.invoice.due_date ? formatDateToLocal(input.invoice.due_date) : 'â€”'}`);
    doc.text(`Status: ${input.invoice.status}`);
    doc.text(`Amount: ${formatAmountForPdf(input.invoice.amount)}`);
    if (input.invoice.description) {
      doc.moveDown(0.5);
      doc.text(`Description: ${input.invoice.description}`);
    }

    doc.fontSize(10).fillColor('#444444').text('Generated by Lateless', 50, 760, { width: 500 });
    doc.end();
  });
}

export async function GET(
  _: Request,
  props: { params: Promise<{ token: string }> },
) {
  const params = await props.params;
  const verification = verifyPayToken(params.token);
  if (!verification.ok) {
    return NextResponse.json({ error: 'Invalid payment link.' }, { status: 404 });
  }

  const [invoice] = await sql<{
    id: string;
    amount: number;
    status: string;
    date: string;
    due_date: string | null;
    invoice_number: string | null;
    description: string | null;
    customer_name: string;
    customer_email: string;
    company_name: string | null;
    address_line1: string | null;
    address_line2: string | null;
    city: string | null;
    country: string | null;
    billing_email: string | null;
  }[]>`
    select
      i.id,
      i.amount,
      i.status,
      i.date,
      i.due_date,
      i.invoice_number,
      i.description,
      c.name as customer_name,
      c.email as customer_email,
      cp.company_name,
      cp.address_line1,
      cp.address_line2,
      cp.city,
      cp.country,
      cp.billing_email
    from public.invoices i
    join public.customers c on c.id = i.customer_id
    left join lateral (
      select
        company_name,
        address_line1,
        address_line2,
        city,
        country,
        billing_email
      from public.company_profiles
      where lower(user_email) = lower(i.user_email)
      order by updated_at desc
      limit 1
    ) cp on true
    where i.id = ${verification.payload.invoiceId}
    limit 1
  `;

  if (!invoice) {
    return NextResponse.json({ error: 'Invoice not found.' }, { status: 404 });
  }

  const companyAddress = [
    invoice.address_line1,
    invoice.address_line2,
    invoice.city,
    invoice.country,
  ]
    .map((value) => value?.trim())
    .filter(Boolean)
    .join(', ');

  const pdfBuffer = await buildInvoicePdf({
    invoice,
    company: {
      companyName: invoice.company_name?.trim() || 'Lateless',
      address: companyAddress,
      companyEmail: invoice.billing_email?.trim() || '',
    },
  });
  const filenameId = invoice.invoice_number ?? invoice.id;

  return new NextResponse(pdfBuffer, {
    headers: {
      'Content-Type': 'application/pdf',
      'Content-Disposition': `attachment; filename="invoice-${filenameId}.pdf"`,
      'Cache-Control': 'no-store, max-age=0',
    },
  });
}
